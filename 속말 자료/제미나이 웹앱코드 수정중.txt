import React, { useEffect, useMemo, useRef, useState } from "react";
import {
  Text,
  View,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  StatusBar,
  SafeAreaView,
  Modal,
  TextInput,
  FlatList,
  Platform,
  Animated,
  Easing,
  ActivityIndicator,
  KeyboardAvoidingView,
  TouchableWithoutFeedback,
  Keyboard,
  Alert,
} from "react-native";

/**
 * ‚úÖ ÏïàÏ†ïÏ†ÅÏù∏ ÌÖêÏÖò Ïä¨ÎùºÏù¥ÎçîÎ•º ÏúÑÌï¥ community Slider ÏÇ¨Ïö©
 * (PanResponder Î∞©ÏãùÏùÄ ÌäπÏ†ï Î†àÏù¥ÏïÑÏõÉ/ÌîåÎû´ÌèºÏóêÏÑú ÌÑ∞ÏπòÍ∞Ä ÏîπÌûàÎäî Í≤ΩÏö∞Í∞Ä ÏûàÏñ¥ÏÑú ÍµêÏ≤¥)
 */
import Slider from "@react-native-community/slider";

/**
 * ‚úÖ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú (Expo)
 */
import * as ImagePicker from "expo-image-picker";

/**
 * ‚úÖ Firebase (modular v9)
 */
import { initializeApp, getApps, getApp } from "firebase/app";
import {
  getFirestore,
  collection,
  addDoc,
  onSnapshot,
  query,
  orderBy,
  serverTimestamp,
} from "firebase/firestore";

/**
 * ‚úÖ Auth persistence Í≤ΩÍ≥† Î∞©ÏßÄ ÏòµÏÖò
 */
import AsyncStorage from "@react-native-async-storage/async-storage";
import {
  getAuth,
  signInAnonymously,
  initializeAuth,
  getReactNativePersistence,
} from "firebase/auth";

/**
 * ‚úÖ Storage (Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú)
 */
import { getStorage, ref, uploadBytes, getDownloadURL } from "firebase/storage";

/* -------------------------------------------------------------------------- */
/*                                Firebase Config                             */
/* -------------------------------------------------------------------------- */
const firebaseConfig = {
  apiKey: "AIzaSyCMG4ku-yN__xRrDTs4GwVPq1m4P8uB6Ug",
  authDomain: "sok-mal.firebaseapp.com",
  projectId: "sok-mal",
  storageBucket: "sok-mal.firebasestorage.app",
  messagingSenderId: "57722700620",
  appId: "1:57722700620:web:91132e24ceed5df6b5c5e9",
  measurementId: "G-43NGDB6WWM",
};

// ‚úÖ Expo Ìï´Î¶¨Î°úÎìúÏóêÏÑúÎèÑ Ï§ëÎ≥µ init Î∞©ÏßÄ
const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
const db = getFirestore(app);

// ‚úÖ Auth persistence (Í∞ÄÎä•ÌïòÎ©¥ Ï†ÅÏö©, Ïã§Ìå®ÌïòÎ©¥ Í∏∞Î≥∏ getAuthÎ°ú fallback)
let auth;
try {
  auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage),
  });
} catch (e) {
  auth = getAuth(app);
}

const storage = getStorage(app);

/* -------------------------------------------------------------------------- */
/*                                   Data                                     */
/* -------------------------------------------------------------------------- */
const RANDOM_TITLES = [
  "üìâ ÎπÑÌä∏ÏΩîÏù∏ -5%.. ÌïúÍ∞ï ÏàòÏò® Ï≤¥ÌÅ¨Î∞©",
  "ü§´ ÎèÖÏÑúÏã§ Í∑ìÏÜçÎßê (ASMR)",
  "ü§¨ ÏßÅÏû• ÏÉÅÏÇ¨ Îí∑Îã¥Ìôî (ÏùµÎ™ÖÎ≥¥Ïû•)",
  "üçú Ï†êÏã¨ Î©îÎâ¥ Ï∂îÏ≤ú Ï¢Ä.. Í≤∞Ï†ïÏû•Ïï† Ïò¥",
  "üëª Ïã§ÏãúÍ∞Ñ Í≥µÌè¨Ïç∞ (BGM ÏûàÏùå)",
  "üí§ Î∂àÎ©¥Ï¶ù ÏπòÎ£åÎ∞© (Ïû†Ïò¨ÎïåÍπåÏßÄ)",
  "üé§ Î∞©Íµ¨ÏÑù ÎÖ∏ÎûòÎ∞©! Ìïú Í≥° ÎΩëÏúºÏã§ Î∂Ñ?",
  "‚öΩ ÏÜêÌù•ÎØº Í≥® ÎÑ£ÏóàÎã§!!! ÎùºÏù¥Î∏å Ï§ëÍ≥Ñ",
  "üíî Ï†Ñ Ïï†Ïù∏ Ïó∞ÎùΩ.. Î∞õÎäîÎã§ vs ÎßåÎã§",
  "üíª Í∞úÎ∞úÏûê Ï∑®ÏóÖ/Ïù¥ÏßÅ ÌòÑÏã§ Ï°∞Ïñ∏",
  "üêà Í≥†ÏñëÏù¥ Í≥®Í≥®ÏÜ° 24ÏãúÍ∞Ñ Ïä§Ìä∏Î¶¨Î∞ç",
  "üó≥Ô∏è ÏßÑÎ≥¥ vs Î≥¥Ïàò, ÎÅùÏû• ÌÜ†Î°† (Îß§ÎÑàÌïÑÏàò)",
  "‚úàÔ∏è ÏùºÎ≥∏ Ïó¨Ìñâ ÏùºÏ†ï Ï¢Ä Î¥êÏ§òÏöî",
  "üéÆ Î°§(LoL) 5:5 ÎÇ¥Ï†Ñ (Ìã∞Ïñ¥ Î¨¥Í¥Ä)",
  "üç∫ ÌòºÏà†ÌïòÎäî ÏÇ¨ÎûåÎì§ÎÅºÎ¶¨ Ïß†~",
  "üé¨ ÎÑ∑ÌîåÎ¶≠Ïä§ Ïã†Ïûë Ïä§Ìè¨ÏùºÎü¨ Î¶¨Î∑∞",
  "üïØÔ∏è ÌÉÄÎ°ú Î¥êÎìúÎ¶ΩÎãàÎã§. Î≥µÏ±ÑÎäî Ï¢ãÏïÑÏöî",
  "üèãÔ∏è Ïò§Ïö¥ÏôÑ! Ìó¨Ïä§Ïû• ÎπåÎü∞ Î™©Í≤©Îã¥",
  "üí∏ Ï£ºÏãù Î¨ºÎ¶∞ ÏÇ¨ÎûåÎì§ ÏúÑÎ°úÎ∞©",
  "üî• ÌÉïÏàòÏú° Î∂ÄÎ®π vs Ï∞çÎ®π Í≤∞Ìåê",
  "ü§° ÏïÑÏû¨Í∞úÍ∑∏ Î∞∞ÌãÄ (ÏõÉÏúºÎ©¥ Í∞ïÌá¥)",
  "üåå Ïö∞Ï£ºÏóê ÎÅùÏù¥ ÏûàÏùÑÍπå? Ïã¨Ïïº Ï≤†Ìïô",
  "üöì ÎÇ¥ Ïßë Ïïû Ï£ºÏ∞® ÏãúÎπÑ Ï°∞Ïñ∏ Ï¢Ä",
  "üéÑ ÌÅ¨Î¶¨Ïä§ÎßàÏä§Ïóê Ìï† Í±∞ ÏóÜÎäî ÏÇ¨Îûå Î™®ÏûÑ",
  "üì± ÏïÑÏù¥Ìè∞ vs Í∞§Îü≠Ïãú, Ï†ÑÏüÅÌÑ∞",
  "ü§Æ ÏàôÏ∑® Ìï¥ÏÜåÎ≤ï Í≥µÏú† Í∏âÌï®",
  "üíá Î®∏Î¶¨ ÎßùÌñàÎäîÎç∞ ÏúÑÎ°ú Ï¢Ä",
  "üéÅ Ïó∞Ïù∏ ÏÑ†Î¨º Ï∂îÏ≤ú (10ÎßåÏõêÎåÄ)",
  "üè† ÏûêÏ∑® ÍøÄÌåÅ Ï†ÑÏàòÎ∞©",
  "üê∂ Í∞ïÏïÑÏßÄÍ∞Ä ÏûêÍæ∏ ÏßñÏñ¥Ïöî „Ö†„Ö†",
  "üéì ÎåÄÌïôÏõê Í∞àÍπå ÎßêÍπå Í≥†ÎØºÏ§ë",
  "üëñ Ìå®ÏÖò ÌÖåÎü¨Î¶¨Ïä§Ìä∏ Íµ¨Ï†úÎ∞©",
  "üç≥ ÏöîÎ¶¨ ÎßùÌï®.. ÏÇ¥Î¶¨Îäî Î≤ï Ï¢Ä",
  "üö¨ Í∏àÏó∞ 1ÏùºÏ∞®.. ÏùëÏõê Ï¢Ä",
  "üßü Ï¢ÄÎπÑ ÏÇ¨ÌÉú ÌÑ∞ÏßÄÎ©¥ Ïñ¥ÎîîÎ°ú Ìäê?",
  "üëΩ Ïô∏Í≥ÑÏù∏ ÎØøÎäî ÏÇ¨Îûå Î™®Ïó¨Îùº",
];

const CATEGORIES = [
  "FINANCE",
  "QUIET",
  "ANGRY",
  "FOOD",
  "HORROR",
  "SLEEP",
  "SING",
  "SPORTS",
  "LOVE",
  "TECH",
  "GAME",
];

const BOT_BANK = {
  FINANCE: [
    "Ï∞®Ìä∏ ÏßÄÍ∏à Ïôú Ïù¥Îûò‚Ä¶ ÎàÑÍ∞Ä ÌåîÏïòÎÉê",
    "Ïó¨Í∏∞ÏÑú Ï§çÏ§ç? ÏïÑÎãàÎ©¥ Í¥ÄÎßù?",
    "ÏßÄÍ∏à ÏÜêÏ†àÌïòÎ©¥ ÎÇòÎßå ÏÜêÌï¥ÏûÑ?",
    "ÌïúÍ∞ïÎ∑∞ Ïù∏Ï¶ù Í∏àÏßÄ „Öã„Öã",
    "Ïò§ÎäòÏùÄ Îâ¥Ïä§Í∞Ä Ïû•ÏùÑ Ï∞¢ÎÑ§",
    "ÎÑàÎ¨¥ Ìù•Î∂ÑÌïòÏßÄ ÎßêÍ≥† Í∑ºÍ±∞Î∂ÄÌÑ∞ ÎßêÌï¥Ï§ò",
  ],
  LOVE: [
    "Í∑∏Í±∞ ÏÑ§Î†àÎäî Í±∞ ÎßûÏßÄ?",
    "ÎãµÏû• ÌÖÄÏù¥ Î™®Îì† Í±∏ ÎßêÌï¥Ï§ÄÎã§‚Ä¶",
    "Ïó∞ÎùΩ ÏôîÏúºÎ©¥ Ïù¥ÎØ∏ Í≤åÏûÑ ÎÅùÎÇ¨Ïùå",
    "Ïó¨Í∏∞ÏÑú Í∞êÏ†ï Ïà®Í∏∞Î©¥ Îçî ÎßùÌï®",
    "Í≥†Î∞± Í∞Å? ÏïÑÎãàÎ©¥ Ïû†Íπê Î©àÏ∂∞",
  ],
  ANGRY: [
    "Í∑∏ ÏÉÅÏÇ¨ Ïù¥Î¶ÑÎßå ÎßêÌï¥Î¥ê (ÎÜçÎã¥)",
    "ÏôÄ‚Ä¶ Í∑∏Í±¥ ÏßÑÏßú ÏÑ† ÎÑòÏóàÎÑ§",
    "Ìá¥ÏÇ¨Îäî Ï∂©ÎèôÏù¥ ÏïÑÎãàÎùº Í≥ÑÌöçÏù¥Îã§",
    "Ïó¨Í∏∞ÏÑúÎäî Ïöï Ï¢Ä Ìï¥ÎèÑ Îê®",
    "Î≥µÏàò ÌîåÎûú ÎßêÍ≥† ÏÉùÏ°¥ ÌîåÎûúÎ∂ÄÌÑ∞",
  ],
  FOOD: [
    "ÏùºÎã® ÎùºÎ©¥Ïóê Í≥ÑÎûÄ ÎÑ£Ïûê",
    "Î∂ÄÎ®π/Ï∞çÎ®π ÎÖºÏüÅÏùÄ ÏÑ∏Í≥ÑÎåÄÏ†ÑÏûÑ",
    "Î∞∞Í≥†ÌîÑÎ©¥ ÌåêÎã®Î†• 0 Îê®",
    "Ïò§ÎäòÏùÄ ÍπÄÏπòÏ∞åÍ∞úÍ∞Ä Ï†ïÎãµ",
    "ÎØºÏ¥àÌåå Îì±Ïû•ÌïòÎ©¥ Î∂ÑÏúÑÍ∏∞ Î∂àÌÉÑÎã§",
  ],
  QUIET: [
    "Ïó¨Í∏∞Îäî ÏÜçÏÇ≠ÏûÑ Î™®Îìú‚Ä¶",
    "Îßê Ï†ÅÏñ¥ÎèÑ Îê®, Îì£Í∏∞Îßå Ìï¥ÎèÑ Îê®",
    "Ïà®ÏÜåÎ¶¨ ASMR Ï¢ãÎã§",
    "Ïò§ÎäòÏùÄ Ï°∞Ïö©Ìûà Ï†ïÎ¶¨ÌïòÏûê",
  ],
  SLEEP: [
    "Ïû† Ïïà Ïò§Î©¥ Îàà Í∞êÍ≥† Í∑∏ÎÉ• Îì§Ïñ¥",
    "Ïò§Îäò ÌïòÎ£® Í≥†ÏÉùÌñàÏñ¥",
    "Ìò∏Ìù° Ï≤úÏ≤úÌûà‚Ä¶",
    "ÎÇ¥Ïùº ÏÉùÍ∞ÅÏùÄ ÎÇ¥ÏùºÏùò ÎÇòÏóêÍ≤å",
  ],
  HORROR: [
    "ÏßÄÍ∏à Îì§Î¶¨Î©¥ Ïïà ÎêòÎäî ÏÜåÎ¶¨ Îì§Î¶º?",
    "Î¨∏ Ïû†Í∞îÏßÄ‚Ä¶?",
    "BGM ÍπîÎ¶∞Îã§, Ïã¨Ïû• Ï§ÄÎπÑ",
    "Ïä§Ìè¨Îäî Í∞ïÌá¥ÏûÑ „Öã„Öã",
  ],
  SING: [
    "Ìïú Í≥° ÎΩëÍ≥† Í∞ÄÏûê",
    "Ïó¨Í∏¥ ÏùåÏπòÎèÑ ÌôòÏòÅÏûÑ",
    "Í≥†ÏùåÏùÄ Ïö©Í∏∞Îã§",
    "ÎßàÏù¥ÌÅ¨ Ïû°ÏùÄ ÏÇ¨Îûå ÏäπÏûê",
  ],
  SPORTS: [
    "ÏßÄÍ∏à Í∑∏ Ïû•Î©¥ Îã§Ïãú Î¥êÏïº Îê®",
    "VAR Î≠êÌïòÎÉê‚Ä¶",
    "Ïò§Îäò Ïª®ÎîîÏÖò ÎØ∏Ï≥§Îã§",
    "ÎÅùÍπåÏßÄ Í∞ÄÎ≥¥Ïûê!",
  ],
  TECH: [
    "Í∑∏Í±∞ Í≤∞Íµ≠ ÎîîÌéúÎçòÏãú Î¨∏Ï†úÏûÑ",
    "Î≤ÑÍ∑∏Îäî Ìï≠ÏÉÅ ÎÇ¥Í∞Ä ÏûêÎäî ÏãúÍ∞ÑÏóê ÌÑ∞Ïßê",
    "Ìïú Ï§Ñ Í≥†ÏπòÎ©¥ 10Ï§Ñ Íπ®ÏßÑÎã§",
    "Ïª§Î∞ã Î©îÏãúÏßÄÎ∂ÄÌÑ∞ Î∞òÏÑ±ÌïòÏûê",
  ],
  GAME: [
    "Î©òÌÉà Í¥ÄÎ¶¨Í∞Ä Ïã§Î†•Ïù¥Îã§",
    "Í∑∏ ÌîΩÏùÄ Ïã∏ÏõÄ ÎÇòÍ≤†Îã§",
    "Ìïú ÌåêÎßå ÎçîÎäî Í±∞ÏßìÎßêÏûÑ",
    "Ìã∞Ïñ¥Îäî ÎßàÏùåÏÜçÏóê ÏûàÎã§",
  ],
  DEFAULT: [
    "Ïó¨Í∏∞ Î∂ÑÏúÑÍ∏∞ Ïôú Ïù¥Î†áÍ≤å Ï¢ãÎÉê",
    "„Öã„Öã„Öã Ïù¥ Î∞© ÏõÉÍ∏∞Îã§",
    "Îì£Í∏∞Îßå Ìï¥ÎèÑ ÎêòÎãàÍπå Ìé∏ÌïòÍ≤å ÏûàÏñ¥",
    "ÎàÑÍ∞Ä Ï†ïÎ¶¨ Ï¢Ä Ìï¥Ï§ò",
  ],
};

const ADJECTIVES = [
  "Ïö∞Ïö∏Ìïú",
  "Ïã†ÎÇú",
  "Î∞∞Í≥†Ìîà",
  "Î∂ÑÎÖ∏Ìïú",
  "ÏÉàÎ≤ΩÍ∞êÏÑ±",
  "Ìá¥ÏÇ¨ÌïòÍ≥†Ìîà",
  "ÏÇ¨ÎûëÏóêÎπ†ÏßÑ",
  "ÏÑºÏπòÌïú",
  "Ï°∏Î¶∞",
  "ÏéàÏ≤ôÌïòÎäî",
];
const NOUNS = ["Í∞êÏûê", "ÌñÑÏä§ÌÑ∞", "Í≥†ÏñëÏù¥", "Í∞úÎ∞úÏûê", "ÏßÅÏû•Ïù∏", "Î∞±Ïàò", "Ìò∏ÎûëÏù¥", "ÌÜ†ÎÅº", "ÏøºÏπ¥", "ÏïåÌååÏπ¥"];
const getRandomNickname = () =>
  `${ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)]} ${NOUNS[Math.floor(Math.random() * NOUNS.length)]}`;

const SORT = {
  DEFAULT: "default",
  TENSION_DESC: "tension_desc",
  TENSION_ASC: "tension_asc",
  PEOPLE_DESC: "people_desc",
  PEOPLE_ASC: "people_asc",
};

/* -------------------------------------------------------------------------- */
/*                                   Theme                                    */
/* -------------------------------------------------------------------------- */
const getTheme = (score) => {
  if (score >= 8.5)
    return {
      bg: "#14060b",
      light: "#FF3B30",
      badge: "HOT",
      bubble: "#FF3B30",
      ring: "rgba(255,59,48,0.25)",
    };
  if (score >= 6.0)
    return {
      bg: "#140f06",
      light: "#FF9F0A",
      badge: "ACTIVE",
      bubble: "#FF9F0A",
      ring: "rgba(255,159,10,0.22)",
    };
  if (score >= 3.5)
    return {
      bg: "#0f0614",
      light: "#AF52DE",
      badge: "TALK",
      bubble: "#AF52DE",
      ring: "rgba(175,82,222,0.22)",
    };
  return {
    bg: "#061014",
    light: "#32ADE6",
    badge: "CALM",
    bubble: "#32ADE6",
    ring: "rgba(50,173,230,0.2)",
  };
};

const getTensionMessage = (score) => {
  if (score < 3) return "ü§´ ÏÜåÍ≥§ÏÜåÍ≥§‚Ä¶ Ï°∞Ïö©Ìûà Îì£Í∏∞ Ï¢ãÏùÄ Î∂ÑÏúÑÍ∏∞";
  if (score < 6) return "‚òï Ï†ÅÎãπÌïú ÌÖêÏÖò, Ìé∏ÏïàÌïú ÏàòÎã§";
  if (score < 9) return "üó£Ô∏è ÏãúÎÅåÎ≤ÖÏ†Å! ÏùòÍ≤¨ ÏèüÏïÑÎÇ¥Îäî Ï§ë";
  return "üî• ÌÖêÏÖò Ìè≠Î∞ú! Í≥†Îßâ Ï£ºÏùò„Öã„Öã";
};

/* -------------------------------------------------------------------------- */
/*                                 UI Pieces                                  */
/* -------------------------------------------------------------------------- */
const PulseAvatar = ({ uri, color }) => {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const opacityAnim = useRef(new Animated.Value(0.45)).current;

  useEffect(() => {
    const loop = Animated.loop(
      Animated.parallel([
        Animated.timing(scaleAnim, {
          toValue: 1.65,
          duration: 1400,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(opacityAnim, {
          toValue: 0,
          duration: 1400,
          easing: Easing.out(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    );
    loop.start();
    return () => loop.stop();
  }, [opacityAnim, scaleAnim]);

  return (
    <View style={{ alignItems: "center", justifyContent: "center", width: 60, height: 60 }}>
      <Animated.View
        style={{
          position: "absolute",
          width: 40,
          height: 40,
          borderRadius: 20,
          backgroundColor: color,
          transform: [{ scale: scaleAnim }],
          opacity: opacityAnim,
        }}
      />
      <Image source={{ uri }} style={{ width: 40, height: 40, borderRadius: 20, borderWidth: 2, borderColor: "white" }} />
    </View>
  );
};

function SortItem({ label, onPress, danger }) {
  return (
    <TouchableOpacity
      onPress={onPress}
      activeOpacity={0.85}
      style={[styles.sortItem, danger && { borderColor: "rgba(255,59,48,0.35)" }]}
    >
      <Text style={[styles.sortItemText, danger && { color: "#FF3B30" }]}>{label}</Text>
    </TouchableOpacity>
  );
}

/* -------------------------------------------------------------------------- */
/*                                    App                                     */
/* -------------------------------------------------------------------------- */
export default function App() {
  const [currentRoom, setCurrentRoom] = useState(null);
  const [rooms, setRooms] = useState([]);
  const [user, setUser] = useState(null);

  const [myTension, setMyTension] = useState(5.0);
  const [myProfile, setMyProfile] = useState({ name: "ÎÇòÍ∑∏ÎÑ§", seed: "Me", points: 1000 });

  const [loading, setLoading] = useState(true);

  // Modals
  const [isCreateModal, setCreateModal] = useState(false);
  const [isProfileModal, setProfileModal] = useState(false);
  const [isSortModal, setSortModal] = useState(false);

  // Create room inputs
  const [newTitle, setNewTitle] = useState("");
  const [newLimit, setNewLimit] = useState(""); // ‚úÖ ÎπàÏπ∏ Ïú†ÏßÄ
  const [newConcept, setNewConcept] = useState("");

  // Profile draft
  const [profileDraft, setProfileDraft] = useState("");

  // Sort mode
  const [sortMode, setSortMode] = useState(SORT.DEFAULT);

  const theme = useMemo(() => getTheme(myTension), [myTension]);

  /* ---------------------------- Firebase bootstrap ---------------------------- */
  useEffect(() => {
    signInAnonymously(auth)
      .then((cred) => {
        setUser(cred.user);
        setMyProfile((prev) => ({ ...prev, name: getRandomNickname(), seed: cred.user.uid }));
      })
      .catch((e) => {
        console.error(e);
        Alert.alert("Î°úÍ∑∏Ïù∏ Ïã§Ìå®", "Firebase Auth ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï§ò.");
      });

    const q = query(collection(db, "rooms"), orderBy("createdAt", "desc"));
    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        const liveRooms = snapshot.docs.map((doc) => {
          const data = doc.data();

          let timeLabel = "Î∞©Í∏à";
          if (data.createdAt?.toMillis) {
            const diff = Date.now() - data.createdAt.toMillis();
            const min = Math.floor(diff / 60000);
            timeLabel = min < 1 ? "Î∞©Í∏à" : min < 60 ? `${min}Î∂Ñ Ï†Ñ` : `${Math.floor(min / 60)}ÏãúÍ∞Ñ Ï†Ñ`;
          }

          return {
            id: doc.id,
            ...data,
            timeLabel,
            createdAtMillis: data.createdAt?.toMillis?.() || Date.now(),
          };
        });

        setRooms(liveRooms);
        setLoading(false);
      },
      (err) => {
        console.error(err);
        setLoading(false);
        Alert.alert(
          "Í∂åÌïú Ïò§Î•ò",
          "Firestore ÏùΩÍ∏∞ Í∂åÌïúÏù¥ ÏóÜÏñ¥. Firebase ÏΩòÏÜîÏùò Firestore RulesÏóêÏÑú read Í∂åÌïúÏùÑ ÌôïÏù∏Ìï¥Ï§ò.\n(ÌòÑÏû¨: Missing or insufficient permissions)"
        );
      }
    );

    return () => unsubscribe();
  }, []);

  /* -------------------------------------------------------------------------- */
  /*                                Slider Component                            */
  /* -------------------------------------------------------------------------- */
  const FlatTensionSlider = ({ tension, setTension, theme }) => {
    return (
      <View style={[styles.sliderBox, { borderColor: theme.light }]}>
        <View style={styles.sliderHeader}>
          <Text style={[styles.sliderLabel, { color: theme.light }]}>TENSION SETTING</Text>
          <Text style={[styles.sliderValue, { color: theme.light }]}>{tension.toFixed(1)}</Text>
        </View>

        {/* ‚úÖ ÏïàÏ†ïÏ†ÅÏù∏ Slider (ÌÉ≠/ÎìúÎûòÍ∑∏ Ï†ïÏÉÅ) */}
        <View style={styles.sliderRow}>
          <Slider
            style={styles.nativeSlider}
            minimumValue={0}
            maximumValue={10}
            step={0.1}
            value={tension}
            onValueChange={(v) => setTension(Number(v.toFixed(1)))}
            minimumTrackTintColor={theme.light}
            maximumTrackTintColor={"rgba(255,255,255,0.18)"}
            thumbTintColor={"#FFFFFF"}
          />
        </View>

        <Text style={styles.sliderDesc}>{getTensionMessage(tension)}</Text>
      </View>
    );
  };

  /* -------------------------------------------------------------------------- */
  /*                               Firestore Actions                            */
  /* -------------------------------------------------------------------------- */
  const explainRulesAlert = () => {
    Alert.alert(
      "ÎûúÎç§ ÏÉùÏÑ± Ïã§Ìå®",
      "ÏßÄÍ∏à ÏóêÎü¨Îäî ÏΩîÎìú Î¨∏Ï†úÍ∞Ä ÏïÑÎãàÎùº Firestore Rules(Í∂åÌïú) Î¨∏Ï†úÏïº.\n\nFirebase ÏΩòÏÜî ‚Üí Firestore Database ‚Üí RulesÏóêÏÑú\nrooms/messagesÏóê ÎåÄÌï¥ auth!=null ÌóàÏö©ÏúºÎ°ú Î∞îÍøîÏ§ò.\n\n(ÎÑàÎäî ÏùµÎ™ÖÎ°úÍ∑∏Ïù∏Ïù¥Îùº request.authÎäî Ï°¥Ïû¨Ìï®)"
    );
  };

  const generateRandomRooms = async () => {
    try {
      const shuffled = [...RANDOM_TITLES].sort(() => 0.5 - Math.random()).slice(0, 5);

      const batch = shuffled.map((title) =>
        addDoc(collection(db, "rooms"), {
          title,
          tension: parseFloat((Math.random() * 10).toFixed(1)),
          category: CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)],
          host: `https://api.dicebear.com/7.x/avataaars/png?seed=${Math.random()}`,
          speakers: 1,
          limit: 20,
          description: "Ìï®Íªò ÎåÄÌôîÌï¥Ïöî!",
          listeners: Math.floor(Math.random() * 900),
          createdAt: serverTimestamp(),
        })
      );

      await Promise.all(batch);
    } catch (e) {
      console.error(e);
      explainRulesAlert();
    }
  };

  const createRoom = async () => {
    if (!newTitle.trim()) {
      Alert.alert("Î∞© Ï†úÎ™© ÌïÑÏöî", "Î∞© Ï†úÎ™©ÏùÄ Íº≠ ÏûÖÎ†•Ìï¥Ï§ò.");
      return;
    }

    const parsed = parseInt(newLimit, 10);
    const limit = Number.isFinite(parsed) && parsed > 0 ? parsed : 20;

    try {
      await addDoc(collection(db, "rooms"), {
        title: newTitle.trim(),
        tension: 5.0,
        category: "CHAT",
        host: `https://api.dicebear.com/7.x/avataaars/png?seed=${user?.uid || Math.random()}`,
        speakers: 1,
        limit,
        description: newConcept?.trim() || "Ìï®Íªò ÎåÄÌôîÌï¥Ïöî!",
        listeners: 0,
        createdAt: serverTimestamp(),
      });

      setCreateModal(false);
      setNewTitle("");
      setNewLimit("");
      setNewConcept("");
    } catch (e) {
      console.error(e);
      explainRulesAlert();
    }
  };

  /* -------------------------------------------------------------------------- */
  /*                               Sorting + Hot Pin                            */
  /* -------------------------------------------------------------------------- */
  const displayRooms = useMemo(() => {
    const withMeta = rooms.map((r) => {
      const hot = (r.tension ?? 0) >= 8.7 || (r.listeners ?? 0) >= 400;
      const people = (r.speakers ?? 0) + (r.listeners ?? 0);
      const closeness = Math.abs((r.tension ?? 0) - myTension);
      return { ...r, _hot: hot, _people: people, _closeness: closeness };
    });

    if (sortMode === SORT.DEFAULT) {
      return [...withMeta].sort((a, b) => {
        if (a._hot !== b._hot) return a._hot ? -1 : 1;
        if (a._closeness !== b._closeness) return a._closeness - b._closeness;
        return (b.createdAtMillis || 0) - (a.createdAtMillis || 0);
      });
    }

    if (sortMode === SORT.TENSION_DESC) return [...withMeta].sort((a, b) => (b.tension || 0) - (a.tension || 0));
    if (sortMode === SORT.TENSION_ASC) return [...withMeta].sort((a, b) => (a.tension || 0) - (b.tension || 0));
    if (sortMode === SORT.PEOPLE_DESC) return [...withMeta].sort((a, b) => (b._people || 0) - (a._people || 0));
    if (sortMode === SORT.PEOPLE_ASC) return [...withMeta].sort((a, b) => (a._people || 0) - (b._people || 0));

    return withMeta;
  }, [rooms, sortMode, myTension]);

  /* -------------------------------------------------------------------------- */
  /*                                   Lobby                                    */
  /* -------------------------------------------------------------------------- */
  const Lobby = () => {
    return (
      <SafeAreaView style={[styles.container, { backgroundColor: theme.bg }]}>
        <StatusBar barStyle="light-content" />

        {/* Header */}
        <View style={styles.header}>
          <View>
            <Text style={styles.headerTitle}>SOK-MAL</Text>
            <Text style={styles.headerSubtitle}>Asia Live Voice Archive</Text>
          </View>

          <TouchableOpacity
            activeOpacity={0.85}
            onPress={() => {
              setProfileDraft(myProfile.name);
              setProfileModal(true);
            }}
            style={styles.pointsBadge}
          >
            <Text style={styles.pointsText}>üíé {myProfile.points}</Text>
            <Image
              source={{ uri: `https://api.dicebear.com/7.x/avataaars/png?seed=${myProfile.seed}` }}
              style={styles.miniAvatar}
            />
          </TouchableOpacity>
        </View>

        <View style={styles.contentPadding}>
          {/* Tension Slider */}
          <FlatTensionSlider tension={myTension} setTension={setMyTension} theme={theme} />

          {/* NOW LIVE + 3 Buttons */}
          <View style={styles.liveRow}>
            <Text style={styles.sectionTitle}>NOW LIVE ({rooms.length})</Text>

            <View style={styles.actionsRow}>
              <TouchableOpacity style={styles.actionBtnGold} onPress={generateRandomRooms} activeOpacity={0.85}>
                <Text style={styles.actionBtnGoldText}>‚ö° ÎûúÎç§ÏÉùÏÑ±</Text>
              </TouchableOpacity>

              <TouchableOpacity style={styles.actionBtn} onPress={() => setCreateModal(true)} activeOpacity={0.85}>
                <Text style={styles.actionBtnText}>Ôºã Î∞© ÎßåÎì§Í∏∞</Text>
              </TouchableOpacity>

              <TouchableOpacity style={styles.actionBtn} onPress={() => setSortModal(true)} activeOpacity={0.85}>
                <Text style={styles.actionBtnText}>Ï†ïÎ†¨ ‚ñæ</Text>
              </TouchableOpacity>
            </View>
          </View>

          {/* Room List */}
          {loading ? (
            <ActivityIndicator size="large" color="white" style={{ marginTop: 40 }} />
          ) : (
            <ScrollView showsVerticalScrollIndicator={false} contentContainerStyle={{ paddingBottom: 40 }}>
              {displayRooms.map((room) => {
                const rTheme = getTheme(room.tension || 0);
                const hot = room._hot;

                return (
                  <TouchableOpacity
                    key={room.id}
                    activeOpacity={0.9}
                    style={[styles.card, { borderColor: rTheme.light, shadowColor: rTheme.light }]}
                    onPress={() => setCurrentRoom(room)}
                  >
                    <View style={styles.cardHeader}>
                      <View style={{ flexDirection: "row", alignItems: "center" }}>
                        <View style={[styles.badge, { borderColor: rTheme.light, backgroundColor: rTheme.ring }]}>
                          <Text style={[styles.badgeText, { color: rTheme.light }]}>{room.category || "CHAT"}</Text>
                        </View>
                        {hot && (
                          <View style={[styles.hotPill, { borderColor: rTheme.light }]}>
                            <Text style={[styles.hotPillText, { color: rTheme.light }]}>üî• HOT</Text>
                          </View>
                        )}
                      </View>

                      <Text style={[styles.tensionText, { color: rTheme.light }]}>{(room.tension ?? 0).toFixed(1)}</Text>
                    </View>

                    <Text style={styles.roomTitle} numberOfLines={2}>
                      {room.title}
                    </Text>

                    <Text style={styles.roomDesc} numberOfLines={1}>
                      {room.description || "Ìï®Íªò ÎåÄÌôîÌï¥Ïöî!"}
                    </Text>

                    <View style={styles.cardFooter}>
                      <Text style={styles.metaText}>
                        üé§ {room.speakers ?? 0}/{room.limit ?? 20}   üéß {room.listeners ?? 0}
                      </Text>
                      <Text style={styles.timeText}>{room.timeLabel || ""}</Text>
                    </View>
                  </TouchableOpacity>
                );
              })}
            </ScrollView>
          )}
        </View>

        {/* ------------------------- Create Room Modal ------------------------- */}
        <Modal visible={isCreateModal} transparent animationType="slide" onRequestClose={() => setCreateModal(false)}>
          <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
            <View style={styles.modalOverlay}>
              <KeyboardAvoidingView behavior={Platform.OS === "ios" ? "padding" : "height"}>
                <View style={styles.modalBox}>
                  <Text style={styles.modalTitle}>ÎåÄÌôîÎ∞© Í∞úÏÑ§</Text>

                  <TextInput
                    style={styles.input}
                    placeholder="Î∞© Ï†úÎ™© (ÌïÑÏàò)"
                    placeholderTextColor="#666"
                    value={newTitle}
                    onChangeText={setNewTitle}
                    returnKeyType="next"
                  />

                  <TextInput
                    style={styles.input}
                    placeholder="Ïù∏Ïõê Ï†úÌïú (ÏÑ†ÌÉù, ÎπÑÏõåÎëêÎ©¥ 20)"
                    placeholderTextColor="#666"
                    value={newLimit}
                    onChangeText={setNewLimit}
                    keyboardType="number-pad"
                    returnKeyType="next"
                  />

                  <TextInput
                    style={[styles.input, { height: 84 }]}
                    placeholder="Î∞© Ïª®ÏÖâ/ÏÜåÍ∞ú (ÏÑ†ÌÉù)"
                    placeholderTextColor="#666"
                    value={newConcept}
                    onChangeText={setNewConcept}
                    multiline
                  />

                  <View style={{ flexDirection: "row", marginTop: 4 }}>
                    <TouchableOpacity
                      style={[styles.modalBtn, { backgroundColor: "#333", marginRight: 10 }]}
                      onPress={() => setCreateModal(false)}
                      activeOpacity={0.85}
                    >
                      <Text style={{ color: "white", fontWeight: "900" }}>Ï∑®ÏÜå</Text>
                    </TouchableOpacity>

                    <TouchableOpacity
                      style={[styles.modalBtn, { backgroundColor: "white" }]}
                      onPress={createRoom}
                      activeOpacity={0.85}
                    >
                      <Text style={{ color: "black", fontWeight: "900" }}>ÎßåÎì§Í∏∞</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </KeyboardAvoidingView>
            </View>
          </TouchableWithoutFeedback>
        </Modal>

        {/* -------------------------- Profile Modal (Fixed) -------------------------- */}
        <Modal visible={isProfileModal} transparent animationType="fade" onRequestClose={() => setProfileModal(false)}>
          <View style={styles.modalOverlay}>
            {/* Î∞∞Í≤Ω ÌÉ≠: Î™®Îã¨Îã´Í∏∞ X, ÌÇ§Î≥¥ÎìúÎßå Îã´Í∏∞ */}
            <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
              <View style={StyleSheet.absoluteFill} />
            </TouchableWithoutFeedback>

            <KeyboardAvoidingView
              behavior={Platform.OS === "ios" ? "padding" : "height"}
              keyboardVerticalOffset={Platform.OS === "ios" ? 24 : 0}
              style={{ width: "100%", alignItems: "center" }}
            >
              <View
                style={styles.modalBox}
                onStartShouldSetResponder={() => true}
                onMoveShouldSetResponder={() => true}
              >
                <Text style={styles.modalTitle}>MY PROFILE</Text>

                <View style={{ alignItems: "center", marginBottom: 14 }}>
                  <Image
                    source={{ uri: `https://api.dicebear.com/7.x/avataaars/png?seed=${myProfile.seed}` }}
                    style={{ width: 84, height: 84, borderRadius: 42, borderWidth: 2, borderColor: "white", marginBottom: 12 }}
                  />

                  <TextInput
                    style={styles.profileInput}
                    value={profileDraft}
                    onChangeText={setProfileDraft}
                    placeholder="ÎãâÎÑ§ÏûÑ ÏûÖÎ†•"
                    placeholderTextColor="#777"
                    autoFocus
                    returnKeyType="done"
                    blurOnSubmit={true}
                    onSubmitEditing={Keyboard.dismiss}
                  />
                </View>

                <View style={{ flexDirection: "row" }}>
                  <TouchableOpacity
                    style={[styles.modalBtn, { backgroundColor: "#333", marginRight: 10 }]}
                    activeOpacity={0.85}
                    onPress={() => {
                      Keyboard.dismiss();
                      setProfileDraft(myProfile.name);
                      setProfileModal(false);
                    }}
                  >
                    <Text style={{ color: "white", fontWeight: "900" }}>Ï∑®ÏÜå</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    style={[styles.modalBtn, { backgroundColor: "white" }]}
                    activeOpacity={0.85}
                    onPress={() => {
                      Keyboard.dismiss();
                      setMyProfile((p) => ({ ...p, name: (profileDraft || "").trim() || p.name }));
                      setProfileModal(false);
                    }}
                  >
                    <Text style={{ color: "black", fontWeight: "900" }}>Ï†ÄÏû•</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </KeyboardAvoidingView>
          </View>
        </Modal>

        {/* ------------------------------ Sort Modal ------------------------------ */}
        <Modal visible={isSortModal} transparent animationType="fade" onRequestClose={() => setSortModal(false)}>
          <TouchableWithoutFeedback onPress={() => setSortModal(false)}>
            <View style={styles.modalOverlay}>
              <TouchableWithoutFeedback onPress={() => {}}>
                <View style={styles.sortBox}>
                  <Text style={styles.modalTitle}>Ï†ïÎ†¨ Í∏∞Ï§Ä</Text>

                  <SortItem
                    label="ÌÖêÏÖò ÎÜíÏùÄ Ïàú"
                    onPress={() => {
                      setSortMode(SORT.TENSION_DESC);
                      setSortModal(false);
                    }}
                  />
                  <SortItem
                    label="ÌÖêÏÖò ÎÇÆÏùÄ Ïàú"
                    onPress={() => {
                      setSortMode(SORT.TENSION_ASC);
                      setSortModal(false);
                    }}
                  />
                  <SortItem
                    label="Ïù∏Ïõê ÎÜíÏùÄ Ïàú"
                    onPress={() => {
                      setSortMode(SORT.PEOPLE_DESC);
                      setSortModal(false);
                    }}
                  />
                  <SortItem
                    label="Ïù∏Ïõê ÎÇÆÏùÄ Ïàú"
                    onPress={() => {
                      setSortMode(SORT.PEOPLE_ASC);
                      setSortModal(false);
                    }}
                  />
                  <SortItem
                    label="Ï¥àÍ∏∞Ìôî (Í∏∞Î≥∏ Ï∂îÏ≤ú)"
                    danger
                    onPress={() => {
                      setSortMode(SORT.DEFAULT);
                      setSortModal(false);
                    }}
                  />
                </View>
              </TouchableWithoutFeedback>
            </View>
          </TouchableWithoutFeedback>
        </Modal>
      </SafeAreaView>
    );
  };

  /* -------------------------------------------------------------------------- */
  /*                                 Room Detail                                */
  /* -------------------------------------------------------------------------- */
  const RoomDetail = ({ room, onBack }) => {
    const [chats, setChats] = useState([]);
    const [chatMsg, setChatMsg] = useState("");
    const [uploading, setUploading] = useState(false);

    const flatListRef = useRef(null);
    const rTheme = getTheme(room.tension || 0);

    // Firestore messages subscribe
    useEffect(() => {
      const q = query(collection(db, "rooms", room.id, "messages"), orderBy("createdAt", "asc"));
      const unsub = onSnapshot(
        q,
        (snapshot) => {
          const list = snapshot.docs.map((d) => ({ id: d.id, ...d.data() }));
          setChats(list);
        },
        (err) => {
          console.error(err);
          Alert.alert(
            "Í∂åÌïú Ïò§Î•ò",
            "messages ÏùΩÍ∏∞ Í∂åÌïúÏù¥ ÏóÜÏñ¥. Firestore RulesÏóêÏÑú rooms/{roomId}/messagesÎèÑ ÌóàÏö©Ìï¥Ï§ò."
          );
        }
      );
      return () => unsub();
    }, [room.id]);

    // ‚úÖ AI Î∞îÎûåÏû°Ïù¥: Î°úÏª¨Îßå Îπ†Î•¥Í≤å (DB Ìè≠Ï£º Î∞©ÏßÄ)
    useEffect(() => {
      const category = room.category || "DEFAULT";
      const bank = BOT_BANK[category] || BOT_BANK.DEFAULT;

      const interval = setInterval(() => {
        const msg = bank[Math.floor(Math.random() * bank.length)];
        setChats((prev) => [
          ...prev,
          {
            id: `bot-${Date.now()}`,
            user: "AI Î∞îÎûåÏû°Ïù¥",
            text: msg,
            isBot: true,
            uid: "bot",
            createdAt: { _fake: true },
          },
        ]);
      }, 1700);

      return () => clearInterval(interval);
    }, [room.category, room.id]);

    const sendChat = async (extra = {}) => {
      const m = (chatMsg || "").trim();
      const hasImage = !!extra.imageUrl;

      if (!m && !hasImage) return;

      setChatMsg("");

      try {
        await addDoc(collection(db, "rooms", room.id, "messages"), {
          text: m,
          user: myProfile.name,
          uid: user?.uid || "anon",
          imageUrl: extra.imageUrl || null,
          createdAt: serverTimestamp(),
        });
      } catch (e) {
        console.error(e);
        Alert.alert(
          "Ï†ÑÏÜ° Ïã§Ìå®",
          "Firestore write Í∂åÌïúÏù¥ ÏóÜÏñ¥. RulesÏóêÏÑú write ÌóàÏö©Ìï¥Ï§ò.\n(Missing or insufficient permissions)"
        );
      }
    };

    const pickAndUploadImage = async () => {
      try {
        setUploading(true);

        // Í∂åÌïú
        const perm = await ImagePicker.requestMediaLibraryPermissionsAsync();
        if (perm.status !== "granted") {
          Alert.alert("Í∂åÌïú ÌïÑÏöî", "ÏÇ¨ÏßÑ Ï†ëÍ∑º Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï§ò.");
          setUploading(false);
          return;
        }

        const result = await ImagePicker.launchImageLibraryAsync({
          mediaTypes: ImagePicker.MediaTypeOptions.Images,
          allowsEditing: true,
          quality: 0.85,
        });

        if (result.canceled) {
          setUploading(false);
          return;
        }

        const uri = result.assets?.[0]?.uri;
        if (!uri) {
          setUploading(false);
          return;
        }

        // blob Î≥ÄÌôò
        const resp = await fetch(uri);
        const blob = await resp.blob();

        const uid = user?.uid || "anon";
        const filePath = `rooms/${room.id}/messages/${uid}/${Date.now()}.jpg`;
        const storageRef = ref(storage, filePath);

        await uploadBytes(storageRef, blob);
        const downloadUrl = await getDownloadURL(storageRef);

        // Ïù¥ÎØ∏ÏßÄ Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞
        await sendChat({ imageUrl: downloadUrl });

        setUploading(false);
      } catch (e) {
        console.error(e);
        setUploading(false);
        Alert.alert(
          "Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®",
          "ÎåÄÎ∂ÄÎ∂Ñ Storage Rules Í∂åÌïú Î¨∏Ï†úÏïº.\nFirebase ÏΩòÏÜî ‚Üí Storage RulesÏóêÏÑú auth!=null write ÌóàÏö©Ìï¥Ï§ò."
        );
      }
    };

    return (
      <SafeAreaView style={[styles.container, { backgroundColor: rTheme.bg }]}>
        <StatusBar barStyle="light-content" />

        <View style={styles.roomHeader}>
          <TouchableOpacity onPress={onBack} activeOpacity={0.8}>
            <Text style={{ color: "white", fontSize: 22, fontWeight: "900" }}>‚Äπ</Text>
          </TouchableOpacity>

          <View style={{ flex: 1, paddingHorizontal: 10 }}>
            <Text style={{ color: "white", fontWeight: "900" }} numberOfLines={1}>
              {room.title}
            </Text>
            <Text style={{ color: rTheme.light, fontSize: 11 }} numberOfLines={1}>
              {room.category || "CHAT"} ‚Ä¢ live
            </Text>
          </View>

          <View style={{ width: 36 }} />
        </View>

        <View style={{ paddingHorizontal: 20 }}>
          <View style={[styles.topicCard, { borderColor: rTheme.light }]}>
            <View style={styles.speakerRow}>
              <PulseAvatar uri={room.host} color={rTheme.light} />
              <View style={{ marginLeft: 12, flex: 1 }}>
                <Text style={{ color: "white", fontWeight: "900" }}>HOST</Text>
                <Text style={{ color: "#bbb", fontSize: 12 }} numberOfLines={1}>
                  {room.description || "Ìï®Íªò ÎåÄÌôîÌï¥Ïöî!"}
                </Text>
              </View>
              <View style={{ alignItems: "flex-end" }}>
                <Text style={{ color: rTheme.light, fontWeight: "900", fontSize: 14 }}>
                  {(room.tension ?? 0).toFixed(1)}
                </Text>
                <Text style={{ color: "#777", fontSize: 11 }}>
                  üé§ {room.speakers ?? 0}/{room.limit ?? 20} ‚Ä¢ üéß {room.listeners ?? 0}
                </Text>
              </View>
            </View>
          </View>
        </View>

        <View style={styles.chatWrap}>
          <FlatList
            ref={flatListRef}
            data={chats}
            keyExtractor={(i) => String(i.id)}
            onContentSizeChange={() => flatListRef.current?.scrollToEnd({ animated: true })}
            contentContainerStyle={{ padding: 18, paddingBottom: 12 }}
            renderItem={({ item }) => {
              const mine = item.uid && user?.uid && item.uid === user.uid;
              const bot = item.uid === "bot" || item.isBot;

              const bubbleStyle = mine
                ? { alignSelf: "flex-end", backgroundColor: rTheme.bubble }
                : bot
                ? { alignSelf: "flex-start", backgroundColor: "rgba(255,255,255,0.10)", borderWidth: 1, borderColor: rTheme.ring }
                : { alignSelf: "flex-start", backgroundColor: "rgba(255,255,255,0.12)" };

              return (
                <View style={[styles.chatBubble, bubbleStyle]}>
                  {!mine && (
                    <Text style={[styles.chatUser, { color: bot ? rTheme.light : "#ddd" }]}>
                      {bot ? "AI Î∞îÎûåÏû°Ïù¥" : item.user || "ÏùµÎ™Ö"}
                    </Text>
                  )}

                  {!!item.text && (
                    <Text style={{ color: "white", fontSize: 14, lineHeight: 20 }}>
                      {item.text}
                    </Text>
                  )}

                  {!!item.imageUrl && (
                    <Image
                      source={{ uri: item.imageUrl }}
                      style={styles.chatImage}
                      resizeMode="cover"
                    />
                  )}
                </View>
              );
            }}
          />
        </View>

        <KeyboardAvoidingView behavior={Platform.OS === "ios" ? "padding" : "height"}>
          <View style={styles.inputArea}>
            {/* Ïù¥ÎØ∏ÏßÄ Ï≤®Î∂Ä */}
            <TouchableOpacity
              onPress={pickAndUploadImage}
              activeOpacity={0.85}
              style={[styles.attachBtn, { borderColor: rTheme.light }]}
              disabled={uploading}
            >
              <Text style={{ color: "white", fontWeight: "900" }}>{uploading ? "‚Ä¶" : "üñº"}</Text>
            </TouchableOpacity>

            <TextInput
              style={styles.chatInput}
              value={chatMsg}
              onChangeText={setChatMsg}
              onSubmitEditing={() => sendChat()}
              placeholder="ÎåÄÌôî Ï∞∏Ïó¨‚Ä¶"
              placeholderTextColor="#8a8a8a"
              returnKeyType="send"
            />
            <TouchableOpacity
              onPress={() => sendChat()}
              style={[styles.sendBtn, { backgroundColor: rTheme.light }]}
              activeOpacity={0.85}
            >
              <Text style={{ fontWeight: "900", color: "black" }}>‚¨Ü</Text>
            </TouchableOpacity>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    );
  };

  return currentRoom ? <RoomDetail room={currentRoom} onBack={() => setCurrentRoom(null)} /> : <Lobby />;
}

/* -------------------------------------------------------------------------- */
/*                                    Styles                                   */
/* -------------------------------------------------------------------------- */
const styles = StyleSheet.create({
  container: { flex: 1 },

  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingHorizontal: 20,
    paddingVertical: 16,
    alignItems: "center",
  },
  headerTitle: { fontSize: 28, fontWeight: "900", color: "white", fontStyle: "italic", letterSpacing: -0.5 },
  headerSubtitle: { fontSize: 11, color: "#b7b7b7", marginTop: 4 },

  pointsBadge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "rgba(255,255,255,0.10)",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 999,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.14)",
  },
  pointsText: { color: "#FFD700", fontWeight: "900", marginRight: 8, fontSize: 12 },
  miniAvatar: { width: 26, height: 26, borderRadius: 13, backgroundColor: "#333" },

  contentPadding: { paddingHorizontal: 20, flex: 1 },

  /* Slider */
  sliderBox: {
    borderRadius: 18,
    padding: 16,
    borderWidth: 1,
    backgroundColor: "rgba(0,0,0,0.42)",
    marginBottom: 14,
  },
  sliderHeader: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginBottom: 10 },
  sliderLabel: { fontSize: 12, fontWeight: "900", letterSpacing: 1.4, opacity: 0.95 },
  sliderValue: { fontSize: 22, fontWeight: "900", fontStyle: "italic" },

  sliderRow: {
    width: "100%",
    paddingHorizontal: 2,
    justifyContent: "center",
  },
  nativeSlider: {
    width: "100%",
    height: 38,
  },
  sliderDesc: { marginTop: 8, textAlign: "center", color: "#d6d6d6", fontSize: 12, fontWeight: "700", opacity: 0.9 },

  /* Live row + actions */
  liveRow: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", marginBottom: 10 },
  sectionTitle: { color: "white", fontSize: 16, fontWeight: "900" },
  actionsRow: { flexDirection: "row", alignItems: "center" },

  actionBtnGold: {
    backgroundColor: "rgba(255,215,0,0.18)",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "rgba(255,215,0,0.55)",
    marginRight: 10,
  },
  actionBtnGoldText: { color: "#FFD700", fontWeight: "900", fontSize: 12 },

  actionBtn: {
    backgroundColor: "rgba(255,255,255,0.10)",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.14)",
    marginRight: 10,
  },
  actionBtnText: { color: "white", fontWeight: "900", fontSize: 12, opacity: 0.95 },

  /* Card */
  card: {
    marginBottom: 14,
    borderRadius: 20,
    padding: 18,
    borderWidth: 1,
    backgroundColor: "rgba(0,0,0,0.40)",
    shadowOpacity: 0.12,
    shadowRadius: 14,
    shadowOffset: { width: 0, height: 8 },
    elevation: 5,
  },
  cardHeader: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginBottom: 10 },
  badge: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 999,
    borderWidth: 1,
    marginRight: 8,
  },
  badgeText: { fontSize: 10, fontWeight: "900", letterSpacing: 0.8 },
  hotPill: {
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 999,
    borderWidth: 1,
    backgroundColor: "rgba(255,255,255,0.06)",
  },
  hotPillText: { fontSize: 10, fontWeight: "900" },
  tensionText: { fontSize: 16, fontWeight: "900", fontStyle: "italic" },

  roomTitle: { fontSize: 16, fontWeight: "900", color: "white", lineHeight: 22 },
  roomDesc: { marginTop: 6, color: "#bcbcbc", fontSize: 12, fontWeight: "700", opacity: 0.9 },

  cardFooter: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginTop: 10 },
  metaText: { color: "#9a9a9a", fontSize: 12, fontWeight: "800" },
  timeText: { color: "#6e6e6e", fontSize: 12, fontWeight: "800" },

  /* Modals */
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.78)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 18,
  },
  modalBox: {
    width: 330,
    backgroundColor: "#151515",
    borderRadius: 24,
    padding: 22,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.12)",
  },
  modalTitle: { color: "white", fontSize: 18, fontWeight: "900", marginBottom: 16, textAlign: "center" },
  input: { backgroundColor: "rgba(255,255,255,0.10)", color: "white", borderRadius: 14, padding: 14, marginBottom: 10, fontWeight: "800" },
  profileInput: {
    width: "100%",
    height: 52,
    backgroundColor: "rgba(255,255,255,0.10)",
    borderRadius: 16,
    color: "white",
    fontSize: 18,
    fontWeight: "900",
    textAlign: "center",
    paddingHorizontal: 14,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.14)",
  },
  modalBtn: { flex: 1, paddingVertical: 14, borderRadius: 14, alignItems: "center" },

  /* Sort */
  sortBox: {
    width: 320,
    backgroundColor: "#151515",
    borderRadius: 24,
    padding: 18,
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.12)",
  },
  sortItem: {
    paddingVertical: 14,
    paddingHorizontal: 14,
    borderRadius: 14,
    backgroundColor: "rgba(255,255,255,0.08)",
    borderWidth: 1,
    borderColor: "rgba(255,255,255,0.12)",
    marginBottom: 10,
  },
  sortItemText: { color: "white", fontWeight: "900", fontSize: 14 },

  /* Room detail */
  roomHeader: { flexDirection: "row", alignItems: "center", justifyContent: "space-between", paddingHorizontal: 16, paddingVertical: 12 },
  topicCard: {
    marginTop: 8,
    padding: 14,
    borderRadius: 20,
    backgroundColor: "rgba(255,255,255,0.06)",
    borderWidth: 1,
  },
  speakerRow: { flexDirection: "row", alignItems: "center" },

  chatWrap: { flex: 1, marginTop: 10 },
  chatBubble: { padding: 12, borderRadius: 16, marginBottom: 10, maxWidth: "84%" },
  chatUser: { fontSize: 10, fontWeight: "900", marginBottom: 4, opacity: 0.95 },

  chatImage: {
    width: 220,
    height: 220,
    borderRadius: 14,
    marginTop: 10,
    backgroundColor: "rgba(255,255,255,0.08)",
  },

  inputArea: {
    flexDirection: "row",
    padding: 14,
    backgroundColor: "rgba(0,0,0,0.65)",
    alignItems: "center",
    borderTopWidth: 1,
    borderTopColor: "rgba(255,255,255,0.08)",
  },
  attachBtn: {
    width: 44,
    height: 44,
    borderRadius: 22,
    borderWidth: 1,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 10,
    backgroundColor: "rgba(255,255,255,0.10)",
  },
  chatInput: {
    flex: 1,
    backgroundColor: "rgba(255,255,255,0.10)",
    color: "white",
    borderRadius: 999,
    paddingHorizontal: 18,
    height: 46,
    marginRight: 10,
    fontWeight: "800",
  },
  sendBtn: { width: 46, height: 46, borderRadius: 23, justifyContent: "center", alignItems: "center" },
});
